// Copyright (c) 2025 Garrett Jennings.
// This File is part of sten. Sten is free software under GPLv3 .
// See LICENSE.txt for details.

package machine

import (
	"log"
	"sten/config"
	"testing"
	"time"
)

type MockSerialPort struct {
	readDelay time.Duration
	error     error
}

var expectedGeminiBits = map[string]StrokePacket{
	//	"Fn":   {0xC0, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#1": {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00},
	//	"#2":   {0x90, 0x00, 0x00, 0x00, 0x00, 0x00},
	//	"#3":   {0x88, 0x00, 0x00, 0x00, 0x00, 0x00},
	//	"#4":   {0x84, 0x00, 0x00, 0x00, 0x00, 0x00},
	//	"#5":   {0x82, 0x00, 0x00, 0x00, 0x00, 0x00},
	//	"#6":   {0x81, 0x00, 0x00, 0x00, 0x00, 0x00},
	"S1-": {0x80, 0x40, 0x00, 0x00, 0x00, 0x00},
	"S2-": {0x80, 0x20, 0x00, 0x00, 0x00, 0x00},
	"T-":  {0x80, 0x10, 0x00, 0x00, 0x00, 0x00},
	"K-":  {0x80, 0x08, 0x00, 0x00, 0x00, 0x00},
	"P-":  {0x80, 0x04, 0x00, 0x00, 0x00, 0x00},
	"W-":  {0x80, 0x02, 0x00, 0x00, 0x00, 0x00},
	"H-":  {0x80, 0x01, 0x00, 0x00, 0x00, 0x00},
	"R-":  {0x80, 0x00, 0x40, 0x00, 0x00, 0x00},
	"A-":  {0x80, 0x00, 0x20, 0x00, 0x00, 0x00},
	"O-":  {0x80, 0x00, 0x10, 0x00, 0x00, 0x00},
	"*1":  {0x80, 0x00, 0x08, 0x00, 0x00, 0x00},
	"*2":  {0x80, 0x00, 0x04, 0x00, 0x00, 0x00},
	//	"res1": {0x80, 0x00, 0x02, 0x00, 0x00, 0x00},
	//	"res2": {0x80, 0x00, 0x01, 0x00, 0x00, 0x00},
	//	"pwr":  {0x80, 0x00, 0x00, 0x40, 0x00, 0x00},
	"*3": {0x80, 0x00, 0x00, 0x20, 0x00, 0x00},
	"*4": {0x80, 0x00, 0x00, 0x10, 0x00, 0x00},
	"-E": {0x80, 0x00, 0x00, 0x08, 0x00, 0x00},
	"-U": {0x80, 0x00, 0x00, 0x04, 0x00, 0x00},
	"-F": {0x80, 0x00, 0x00, 0x02, 0x00, 0x00},
	"-R": {0x80, 0x00, 0x00, 0x01, 0x00, 0x00},
	"-P": {0x80, 0x00, 0x00, 0x00, 0x40, 0x00},
	"-B": {0x80, 0x00, 0x00, 0x00, 0x20, 0x00},
	"-L": {0x80, 0x00, 0x00, 0x00, 0x10, 0x00},
	"-G": {0x80, 0x00, 0x00, 0x00, 0x08, 0x00},
	"-T": {0x80, 0x00, 0x00, 0x00, 0x04, 0x00},
	"-S": {0x80, 0x00, 0x00, 0x00, 0x02, 0x00},
	"-D": {0x80, 0x00, 0x00, 0x00, 0x01, 0x00},
	//	"#7":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x40},
	//	"#8":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x20},
	//	"#9":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x10},
	//	"#A":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x08},
	//	"#B":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x04},
	//	"#C":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x02},
	"-Z": {0x80, 0x00, 0x00, 0x00, 0x00, 0x01},
}

func TestProcessPacket_ValidChordPacket(t *testing.T) {
	_, err := config.Load("../config.json")
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	packet := StrokePacket{0x80, 0x18, 0x30, 0x00, 0x51, 0x00} // T- K- A- O- -P -L -D Chord spells "doomed"

	expected := "TKAOPLD"

	stroke, err := packet.toStroke()
	if err != nil {
		t.Fatalf("packet failed to parse")
	}
	steno := stroke.Steno()
	if len(steno) == 0 {
		t.Errorf("expected stroke")
	}

	if steno != expected {
		t.Errorf("expected %s got %v", expected, steno)
	}
}

func TestGeminiPacketEncoding(t *testing.T) {
	_, err := config.Load("../config.json")
	if err != nil {
		log.Fatalf("Failed to load config: %v", err)
	}

	for expected, packet := range expectedGeminiBits {
		stroke, err := packet.toStroke()
		if err != nil {
			t.Fatalf("packet failed to parse")
		}
		steno := stroke.Steno()
		if len(steno) == 1 && steno != config.Layout[expected] { // no dashes
			t.Errorf("expected %v, got %v", config.Layout[expected], steno)
		}
		if len(steno) == 2 && steno != expected { // with dashes
			t.Errorf("expected %v, got %v", config.Layout[expected], steno)
		}
	}
}

func TestProcessPacket_InvalidFirstByte(t *testing.T) {
	packet := StrokePacket{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	_, err := packet.toStroke()
	if err == nil {
		t.Errorf("Packet parsed incorrectly")
	}
}

func TestProcessPacket_InvalidOtherByte(t *testing.T) {
	packet := StrokePacket{0x80, 0x80, 0x00, 0x00, 0x00, 0x00}
	_, err := packet.toStroke()
	if err == nil {
		t.Errorf("Packet parsed incorrectly")
	}
}

func TestStartStopCapture(t *testing.T) {
	m := NewGeminiPrMachine("/dev/null", 9600)
	err := m.StartCapture()
	if err == nil {
		t.Error("expected failure on opening /dev/null as serial port")
	}
}

func TestNewGeminiPrMachineDefaults(t *testing.T) {
	m := NewGeminiPrMachine("test", 1234)
	if m == nil {
		t.Fatal("expected machine instance, got nil")
	}
	if m.baudRate != 1234 || m.portName != "test" {
		t.Errorf("unexpected config: %+v", m)
	}
}

func TestReadLoopStops(t *testing.T) {
	mockPort := &MockSerialPort{
		readDelay: 0,
		error:     nil,
	}
	m := NewGeminiPrMachine("", 0)
	m.port = mockPort

	m.StartCapture()
	m.StopCapture()
}

func (m *MockSerialPort) Read(p []byte) (int, error) {
	time.Sleep(m.readDelay)
	return 0, m.error
}

func (m *MockSerialPort) Close() error {
	return nil
}
